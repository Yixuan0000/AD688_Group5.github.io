{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Multiple Linear Regression - Salary Predition\"\n",
        "subtitle: \"\"\n",
        "\n",
        "bibliography: references.bib\n",
        "csl: csl/econometrica.csl\n",
        "format: \n",
        "  html:\n",
        "    toc: true\n",
        "    number-sections: true\n",
        "    df-print: paged\n",
        "    code: false\n",
        "    code-tools: true\n",
        "    section-divs: true\n",
        "---\n",
        "\n",
        "\n",
        "# Mutiple Linear Regression"
      ],
      "id": "61bbbaaa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "import os, json\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import plotly.express as px\n",
        "import matplotlib.pyplot as plt\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import mean_squared_error, r2_score\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.cluster import KMeans\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "import plotly.graph_objects as go"
      ],
      "id": "5a0e1fec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "df = pd.read_csv('files/cleaned_job_postings.csv')"
      ],
      "id": "929cadf8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "df.head()"
      ],
      "id": "4a2a7bc1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#df.columns"
      ],
      "id": "278145f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df[\"exp_mid\"] = df[[\"MIN_YEARS_EXPERIENCE\", \"MAX_YEARS_EXPERIENCE\"]].mean(axis=1)\n",
        "\n",
        "df[\"skill_count\"] = df[\"SPECIALIZED_SKILLS_NAME\"].fillna(\"\").str.count(\",\") + 1\n",
        "\n",
        "df[\"has_python\"] = df[\"SPECIALIZED_SKILLS_NAME\"].str.contains(\"Python\", case=False, na=False).astype(int)\n",
        "\n",
        "df[\"edu_ge_bachelors\"] = df[\"MIN_EDULEVELS_NAME\"].isin(\n",
        "    [\"Bachelor's Degree\", \"Master's Degree\", \"Doctoral Degree\"]\n",
        ").astype(int)\n",
        "\n",
        "keep_num  = [\"exp_mid\", \"MODELED_DURATION\", \"skill_count\",\n",
        "             \"has_python\", \"edu_ge_bachelors\"]\n",
        "\n",
        "keep_cat  = [\"EMPLOYMENT_TYPE_NAME\", \"REMOTE_TYPE_NAME\",\n",
        "             \"STATE_NAME\", \n",
        "             \"SOC_2021_4_NAME\"]\n",
        "\n",
        "df_model = (\n",
        "    df.dropna(subset=[\"SALARY\"])      \n",
        "      .loc[:, keep_num + keep_cat + [\"SALARY\"]]  \n",
        ")"
      ],
      "id": "9cf6d8bf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df_dummies = pd.get_dummies(\n",
        "    df_model,\n",
        "    columns = keep_cat,   \n",
        "    drop_first = True,   \n",
        "    dtype = float        \n",
        ")"
      ],
      "id": "c45e27c3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "print(df_dummies.shape)\n",
        "print(df_dummies.dtypes.head(10))"
      ],
      "id": "7bb6e756",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Drop salary to form features\n",
        "X = df_dummies.drop('SALARY', axis = 1)\n",
        "y = df_dummies['SALARY']\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y ,test_size = 0.3, random_state = 688)"
      ],
      "id": "3036f1de",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model = LinearRegression()\n",
        "model.fit(X_train, y_train)"
      ],
      "id": "882f2c0d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "y_pred = model.predict(X_test)\n",
        "pd.Series(y_pred).describe()"
      ],
      "id": "6ad18838",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "rmse = mean_squared_error(y_test, y_pred)\n",
        "r2 = r2_score(y_test, y_pred)\n",
        "\n",
        "print(f\"RMSE: {rmse:.2f}\")\n",
        "print(f\"R-squared: {r2:.4f}\")"
      ],
      "id": "a4a56c49",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "coef_df = pd.DataFrame({\n",
        "    \"Feature\": X.columns,\n",
        "    \"Coefficient\": model.coef_\n",
        "}).sort_values(by=\"Coefficient\", ascending=False)\n",
        "\n",
        "coef_df.head(10)"
      ],
      "id": "8b0394b8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "coef_cleaned = coef_df[~coef_df['Feature'].str.contains(\"Unknown|\\[None\\]\", regex=True)]\n",
        "\n",
        "coef_cleaned.head(10)"
      ],
      "id": "b323b638",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Random Forest"
      ],
      "id": "70e1f960"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "lm  = LinearRegression().fit(X_train, y_train)"
      ],
      "id": "56074baf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "rf   = RandomForestRegressor(n_estimators=300, random_state=688).fit(X_train, y_train)"
      ],
      "id": "ebbde8df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Visualization \n"
      ],
      "id": "401185d5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "figures_folder = \"figures\"\n",
        "if not os.path.exists(figures_folder):\n",
        "    os.makedirs(figures_folder)"
      ],
      "id": "2b6854b7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 1. Coefficient bar chart\n",
        "fig = px.bar(coef_df, x=\"Coefficient\", y=\"Feature\", orientation=\"h\",\n",
        "             title=\"Top 15 Positive/Negative MLR Coefficients\",\n",
        "             template=\"plotly_white\", width=800, height=550)\n",
        "fig.update_yaxes(autorange=\"reversed\")\n",
        "fig.write_html(os.path.join(figures_folder, \"MLR_Coefficients.html\"))"
      ],
      "id": "d55df745",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<iframe src=\"figures/MLR_Coefficients.html\" width=\"100%\" height=\"550\"></iframe>\n"
      ],
      "id": "b1df42e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 2. Actual vs. Predicted\n",
        "fig = go.Figure()\n",
        "fig.add_trace(go.Scatter(\n",
        "    x=y_test, y=y_pred, mode=\"markers\", name=\"Observations\",\n",
        "    marker=dict(size=6, opacity=0.6)\n",
        "))\n",
        "lims = [min(y_test.min(), y_pred.min()), max(y_test.max(), y_pred.max())]\n",
        "fig.add_shape(type=\"line\", x0=lims[0], y0=lims[0],\n",
        "              x1=lims[1], y1=lims[1],\n",
        "              line=dict(dash=\"dash\", width=2, color=\"red\"))\n",
        "fig.update_layout(\n",
        "    title=\"MLR – Actual vs. Predicted\",\n",
        "    xaxis_title=\"Actual Salary\",\n",
        "    yaxis_title=\"Predicted Salary\",\n",
        "    template=\"plotly_white\", width=800, height=550\n",
        ")\n",
        "fig.write_html(os.path.join(figures_folder, \"MLR_AVP.html\"))"
      ],
      "id": "e065371b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<iframe src=\"figures/MLR_AVP.html\" width=\"100%\" height=\"550\"></iframe>\n"
      ],
      "id": "3c58b3ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 3. Residual histogram\n",
        "resid = y_test - y_pred\n",
        "fig = px.histogram(resid, nbins=40,\n",
        "                   title=\"MLR Residual Distribution\",\n",
        "                   labels={\"value\":\"Error (Actual – Predicted)\"},\n",
        "                   template=\"plotly_white\", width=800, height=500)\n",
        "fig.write_html(os.path.join(figures_folder, \"MLR_Residuals.html\"))\n",
        "fig"
      ],
      "id": "8f20add8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<iframe src=\"figures/MLR_Residuals.html\" width=\"100%\" height=\"550\"></iframe>\n",
        "\n",
        "# Unsupervised Learning - Kmeans \n"
      ],
      "id": "567fc2fd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "scaler = StandardScaler()\n",
        "X_scaled = scaler.fit_transform(df_dummies)"
      ],
      "id": "383ead03",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "wcss = []\n",
        "K_range = range(2, 11)\n",
        "\n",
        "for k in K_range:\n",
        "    km = KMeans(n_clusters=k, n_init=10, random_state=688)\n",
        "    km.fit(X_scaled)\n",
        "    wcss.append(km.inertia_)"
      ],
      "id": "3223683b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Elbow Plot\n",
        "fig = go.Figure()\n",
        "\n",
        "fig.add_trace(go.Scatter(\n",
        "    x=list(K_range),\n",
        "    y=wcss,\n",
        "    mode='lines+markers',\n",
        "    marker=dict(size=8),\n",
        "    line=dict(width=2),\n",
        "    name='WCSS'\n",
        "))\n",
        "\n",
        "fig.update_layout(\n",
        "    title='Elbow Method - Within-Cluster Sum of Squares',\n",
        "    xaxis_title='Number of Clusters (k)',\n",
        "    yaxis_title='WCSS',\n",
        "    template='plotly_white',\n",
        "    width=800,\n",
        "    height=500\n",
        ")\n",
        "\n",
        "fig.write_html(os.path.join(figures_folder, \"Elbow_Chart.html\"))"
      ],
      "id": "ccd5f6da",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<iframe src=\"figures/Elbow_Chart.html\" width=\"100%\" height=\"500\"></iframe>"
      ],
      "id": "7a3e1a38"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# From the elbow Plot, we take k = 4\n",
        "kmeans = KMeans(n_clusters=4, n_init=10, random_state=688)\n",
        "\n",
        "cluster_labels = kmeans.fit_predict(X_scaled)\n",
        "\n",
        "df['cluster'] = cluster_labels"
      ],
      "id": "29fc7ccc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(df['cluster'].value_counts().sort_index())"
      ],
      "id": "43b13f7b",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}